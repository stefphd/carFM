function ymdres = ymd(car, u_long0, delta0, lambda0, opts)
%YMD See help/ymd.m for the help of this function.

% Checks args
arguments
    car (1,1) struct {carfm.common.checkCarStruct(car)}
    u_long0 (3,1) {mustBeNumeric,mustBeReal}
    delta0 (:,1) {mustBeNumeric,mustBeReal,carfm.common.mustBeEqualSize2(delta0,u_long0)}
    lambda0 (:,1) {mustBeNumeric,mustBeReal,carfm.common.mustBeEqualSize2(lambda0,u_long0)}
    opts (1,1) struct {carfm.ssa.checkOptStruct(opts)} = struct()
end

% Add path and import
filepath = fileparts(mfilename('fullpath')); % path of current file
[flag, errid, errmsg] = carfm.common.setEnvironment(filepath); % check tools and set path
if flag
    % Reset and exit
    clearvars -except filepath errmsg
    carfm.common.setEnvironment(filepath, false);
    % Give error if sth went wrong
    error(errid, '%s', errmsg);
end

% Default options and override with user-defined options
opts = carfm.ssa.getDefaultOptions(opts);

% Get undocumented options and override with user-defined options
opts = carfm.ssa.getUndocOptions(opts);

% Generate symbolic expression using CasADi only if ~usePrebuilt or ~mex
% this is to reduce overhead when not necessary, thus reducing function inizialization time
if ~opts.mex || ~opts.usePrebuilt
    % Create vars
    V = casadi.MX.sym('V');
    a__t = casadi.MX.sym('a__t');
    Tau__t = casadi.MX.sym('Tau__t');
    % delta = casadi.MX.sym('delta');
    % lambda = casadi.MX.sym('lambda');
    p = casadi.MX.sym('p', 2); % [delta; lambda]
    
    % Create u_long and u_lat
    u_long = [V; a__t; Tau__t];
    u_lat = [0; p];

    % Create x = [phi, mu, z, delta, z__fl, z__fr, z__rl, z__rr, lambda, kappa__fl, kappa__fr, kappa__rl, kappa__rr
    %             X__fl,X__fr,X__rl,X__rr,Y__fl,Y__fr,Y__rl,Y__rr,N__fl,N__fr,N__rl,N__rr
    %             F__fl, F__fr, F__rl, F__rr, Tau__t, V, yaw__rate, a__t, M__z]
    x = casadi.MX.sym('x', 33+1, 1);

    % Options
    opts.ssActiveLatInputs = [false, true, true]; % assign delta, lambda
    % M__z is yaw moment generated by the car, i.e. ext torque has '-'
    M__z = x(end);
    opts.extTorque = opts.extTorque - [0 0 M__z]; % assign ext torque
    
    % Create system function zero = f(x, u_long, u_lat)
    car_casadi = carfm.common.matlab2casadiInterpolant(car);
    [ssres, ssdata] = carfm.ssa.steadyStateEquations(x(1:33), u_long, u_lat, car_casadi, opts);
    f = casadi.Function('f', {x, u_long, p}, {ssres, ssdata.residual});

    % Create guess function xg = guess(u_long, u_lat)
    xg = carfm.ssa.steadyStateGuess(u_long, u_lat, car_casadi, opts);
    xg = [xg; 0]; % add yaw moment guess
    guessfun = casadi.Function('guess', {u_long, p}, {xg});

    % Create function extTorque = get_extTorque(M__z)
    extTorque = casadi.Function('extTorque', {x}, {opts.extTorque});

    % Solver to find zero of f
    solver = casadi.rootfinder('solver', opts.ssSolver, f, struct('error_on_fail', false));
    
    % Stability and control
    % control: dMz/ddelta
    % stability: dMz/dbeta
    solx = solver(x, u_long, p);
    dMzdp = jacobian(solx(end), p); % dMz/d(delta, lambda)
    
    % Create unique function
    f = casadi.Function('f', {x, u_long, p}, {ssres, x(1:end-1), M__z, ssdata.lateralAcc, dMzdp, ssdata.residual});

    % Solver to find zero of f
    solver = casadi.rootfinder('solver', opts.ssSolver, f, struct('error_on_fail', false));
end

% TODO add option
opts.ymdMexName = 'ymdSolver';

% Mex
% for mex=true, force build if buildOnly=true, regardless usePrebuilt
if opts.mex && (~opts.usePrebuilt || opts.buildOnly)
    [flag, errid, errmsg] = carfm.ssa.mexFile(opts.ymdMexName, guessfun, solver, extTorque); % mex functions
    if flag
        % Reset and exit
        clearvars -except filepath errmsg
        carfm.common.setEnvironment(filepath, false);
        % Give error if sth wrong
        error(errid, '%s', errmsg);
    end
end

% Mex exists?
if opts.mex 
    if exist(opts.ymdMexName, 'file')~=3 % id=3 for mex file (https://it.mathworks.com/help/matlab/ref/exist.html)
        % Reset and exit
        clearvars -except filepath opts
        carfm.common.setEnvironment(filepath, false);
        % Give error
        error('carfm:notFound','Unable to find MEX function %s.%s', opts.ymdMexName, mexext)
    end
end

% Check for build only
if opts.mex && opts.buildOnly
    % Reset and exit
    clearvars -except filepath
    carfm.common.setEnvironment(filepath, false);
    ssdata = struct([]); % empty output argument
    return;
end

% Get function
if opts.mex
    % Function handles for easier access to the functions in the mex
    ymdsolver_fh = str2func(opts.ymdMexName); % function handle for ssasolver
    eval_guess = @(varargin) ymdsolver_fh('guess', varargin{:});
    eval_extTorque = @(varargin) ymdsolver_fh('extTorque', varargin{:});
    solver = @(x, varargin) ymdsolver_fh('solver', x, varargin{:});
else
    % Function handles which return data in double (and not casadi.DM type)
    eval_guess = returntypes('full', guessfun);
    eval_extTorque = returntypes('full', extTorque);
    solver = returntypes('full', solver);
end

% Solve YMD
clear ssdata
Xsol = nan(numel(lambda0),numel(delta0),numel(opts.xscale)); % matrix containing solution x
MZsol = nan(numel(lambda0),numel(delta0));
AYsol = nan(numel(lambda0),numel(delta0));
DMZsol = nan(numel(lambda0),numel(delta0), 2);
% Loop over lambda (first dimension)
for k1 = 1 : numel(lambda0)
    % Loop over delta (second dimension)
    for k2 = 1 : numel(delta0)
        % Create arguments for solver
        args = {u_long0, [delta0(k2); lambda0(k1)]};
        % Get guess x
        if ~opts.useLastSSA || k2==1
            x0 = eval_guess(args{:});
        end
        % Call to solver
        [xsol, xsol1, Mzsol, aysol, dMzsol] = solver(x0, args{:});
        Xsol(k1,k2,:) = xsol1;
        MZsol(k1,k2) = Mzsol;
        AYsol(k1,k2) = aysol;
        DMZsol(k1,k2,:) = dMzsol;
        % Post processing
        opts.extTorque = eval_extTorque(xsol);
        [~, ssdata(k1,k2)] = carfm.ssa.steadyStateEquations(xsol1, u_long0, [0; delta0(k2); lambda0(k1)], car, opts);
        if ssdata(k1,k2).exitcode ~= 0
            MZsol(k1,k2) = nan;
            AYsol(k1,k2) = nan;
            % Give warning for failed or invalid solution
            fprintf('%s at index=(%d,%d) (exitcode %d)\n', ssdata(k1,k2).exitmsg, k1, k2, ssdata(k1,k2).exitcode);
        end
        % Set next guess
        if opts.useLastSSA && ssdata(k1,k2).exitcode >= 0 
            x0 = xsol;
        end
    end
end



    


end

